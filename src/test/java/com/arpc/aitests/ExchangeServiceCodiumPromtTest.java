package com.arpc.aitests;

// Generated by CodiumAI
// custom prompt provided as General Instructions
/**
 * Write jUnit test where:
 * 1) method names must start with "should" and can have "When"
 * 1) don't use underscores in method names
 * 2) Tests should be exhaustive and cover all edge cases
 * 3) reuse fields initiated before test to reduce code repetition
 * 4) utilize helper methods to reduce code repetition between tests
 * 5) Output only the code
 * 6) Use assertJ assertions
 * 7) Use Lombok builders when possible
 * 8) Use helpers and test doubles from existing context if appropriate
 */


import org.javamoney.moneta.convert.ExchangeRateBuilder;
import org.javamoney.moneta.spi.DefaultNumberValue;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.money.CurrencyUnit;
import javax.money.Monetary;
import javax.money.convert.ExchangeRate;
import javax.money.convert.ExchangeRateProvider;
import javax.money.convert.MonetaryConversions;
import javax.money.convert.RateType;
import java.math.BigDecimal;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class ExchangeServiceCodiumPromtTest {

    ExchangeService exchangeService;

    ExchangeRateProvider provider;

    @BeforeEach
    void setUp() {
        provider = Mockito.mock(ExchangeRateProvider.class);
        exchangeService = new ExchangeService(provider);
    }

    // Can retrieve exchange rate for valid source and target currency
    @Test
    public void shouldRetrieveExchangeRateForValidSourceAndTargetCurrency() {
        // Arrange
        CurrencyUnit sourceCurrency = Monetary.getCurrency("USD");
        CurrencyUnit targetCurrency = Monetary.getCurrency("EUR");
        when(provider.getExchangeRate(sourceCurrency, targetCurrency)).thenReturn(createMockExchangeRate(sourceCurrency, targetCurrency));
    
        // Act
        Optional<ExchangeRate> exchangeRate = exchangeService.getExchangeRate(sourceCurrency, targetCurrency);
    
        // Assert
        assertThat(exchangeRate).isPresent();
    }

    // Returns empty optional for invalid currency codes
    @Test
    public void shouldReturnEmptyOptionalForInvalidCurrencyCodes() {
        // Arrange
        String sourceCurrency = "INVALID";
        String targetCurrency = "EUR";
    
        // Act
        Optional<ExchangeRate> exchangeRate = exchangeService.getExchangeRate(sourceCurrency, targetCurrency);
    
        // Assert
        assertThat(exchangeRate).isEmpty();
    }

    // Can't retrieve exchange rate for same source and target currency
    @Test
    public void shouldNotReceiveForSameSourceAndTargetCurrency() {
        // Arrange
        CurrencyUnit currency = Monetary.getCurrency("USD");
    
        // Act
        Optional<ExchangeRate> exchangeRate = exchangeService.getExchangeRate(currency, currency);
    
        // Assert
        assertThat(exchangeRate).isEmpty();
    }

    // Can retrieve exchange rate for different source and target currency
    @Test
    public void shouldRetrieveExchangeRateForDifferentSourceAndTargetCurrency() {
        // Arrange
        CurrencyUnit sourceCurrency = Monetary.getCurrency("USD");
        CurrencyUnit targetCurrency = Monetary.getCurrency("EUR");
        when(provider.getExchangeRate(sourceCurrency, targetCurrency)).thenReturn(createMockExchangeRate(sourceCurrency, targetCurrency));
    
        // Act
        Optional<ExchangeRate> exchangeRate = exchangeService.getExchangeRate(sourceCurrency, targetCurrency);
    
        // Assert
        assertThat(exchangeRate).isPresent();
    }

    // Returns empty optional for unsupported currency codes
    @Test
    public void shouldReturnEmptyOptionalForUnsupportedCurrencyCodes() {
        // Arrange
        String sourceCurrency = "USD";
        String targetCurrency = "UNSUPPORTED";
    
        // Act
        Optional<ExchangeRate> exchangeRate = exchangeService.getExchangeRate(sourceCurrency, targetCurrency);
    
        // Assert
        assertThat(exchangeRate).isEmpty();
    }

    // Returns empty optional for null source and target currency codes
    @Test
    public void shouldReturnExceptionForNullSourceAndTargetCurrencyCodes() {
        // Arrange
        String sourceCurrency = null;
        String targetCurrency = null;
    
        // Act
        assertThatThrownBy(() -> exchangeService.getExchangeRate(sourceCurrency, targetCurrency))
                .isInstanceOf(NullPointerException.class);
    }

    // Returns empty optional for empty source and target currency codes
    @Test
    public void shouldReturnEmptyOptionalForEmptySourceAndTargetCurrencyCodes() {
        // Arrange
        String sourceCurrency = "";
        String targetCurrency = "";
    
        // Act
        Optional<ExchangeRate> exchangeRate = exchangeService.getExchangeRate(sourceCurrency, targetCurrency);
    
        // Assert
        assertThat(exchangeRate).isEmpty();
    }

    // Returns empty optional for non-existent source and target currency codes
    @Test
    public void shouldReturnEmptyOptionalForNonExistentSourceAndTargetCurrencyCodes() {
        // Arrange
        String sourceCurrency = "NON_EXISTENT";
        String targetCurrency = "EUR";
    
        // Act
        Optional<ExchangeRate> exchangeRate = exchangeService.getExchangeRate(sourceCurrency, targetCurrency);
    
        // Assert
        assertThat(exchangeRate).isEmpty();
    }

    //handwritten to fix tests
    private ExchangeRate createMockExchangeRate(CurrencyUnit sourceCurrency, CurrencyUnit targetCurrency) {
        return new ExchangeRateBuilder("mock", RateType.REALTIME)
                .setBase(sourceCurrency)
                .setFactor(new DefaultNumberValue(new BigDecimal(2.0)))
                .setTerm(targetCurrency)
                .build();
    }

}